package tencent.leetcode901_950;

/**
 * @author inta
 * @date 2019/11/5
 * @describe 在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）
 *
 * 现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。
 *
 * 返回必须翻转的 0 的最小数目。（可以保证答案至少是 1。）
 *
 *  
 *
 * 示例 1：
 *
 * 输入：[[0,1],[1,0]]
 * 输出：1
 * 示例 2：
 *
 * 输入：[[0,1,0],[0,0,0],[0,0,1]]
 * 输出：2
 * 示例 3：
 *
 * 输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
 * 输出：1
 *  
 *
 * 提示：
 *
 * 1 <= A.length = A[0].length <= 100
 * A[i][j] == 0 或 A[i][j] == 1
 */
public class Q934shortestBridge {
    //思路，第一次dfs找到一个岛屿所有位置，并保存，然后遍历所有位置以进行bfs搜索能否触及另一个岛屿
    public int shortestBridge(int[][] A) {
        //题意得，其为nxn得矩阵
        int n = A.length;
        //TODO 待定
        return 1;
    }
}
